<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KEDA-Knative-Kafka-Scaling-Guide</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; }
        pre code { background: none; padding: 0; }
        blockquote { border-left: 4px solid #ddd; margin: 0; padding-left: 20px; color: #666; }
        h1, h2, h3 { color: #333; }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <h1>Testing KEDA Scaling for Knative Kafka Components</h1>
<h2>Overview</h2>
<p>KEDA scales Knative Kafka components through <strong>annotation-based autoscaling</strong> on Triggers and direct <strong>ScaledObject</strong> configurations for the data plane components:</p>
<ol>
<li><strong>kafka-broker-dispatcher</strong> (StatefulSet) - Scales based on consumer group lag</li>
<li><strong>kafka-broker-receiver</strong> (Deployment) - Scales based on incoming request volume</li>
<li><strong>Consumer Groups</strong> - Individual triggers get their own consumer groups that scale independently</li>
</ol>
<h2>Prerequisites</h2>
<ol>
<li><strong>Enable KEDA Controller</strong>: Apply the feature flag configuration</li>
<li><strong>Install KEDA</strong>: In your EKS cluster</li>
<li><strong>Configure MSK Authentication</strong>: SCRAM-SHA-512 or IAM</li>
</ol>
<h2>Step 1: Enable KEDA Autoscaling</h2>
<pre><code class="language-bash"># Enable KEDA controller in Knative
kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-kafka-features
  namespace: knative-eventing
data:
  controller-autoscaler-keda: &quot;enabled&quot;
EOF
</code></pre>
<h2>Step 2: Configure MSK Authentication</h2>
<pre><code class="language-bash"># Create MSK authentication secret
kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Secret
metadata:
  name: kafka-secret
  namespace: knative-eventing
type: Opaque
data:
  user: $(echo -n &quot;your-msk-username&quot; | base64)
  password: $(echo -n &quot;your-msk-password&quot; | base64)
  protocol: $(echo -n &quot;SASL_SSL&quot; | base64)
  sasl.mechanism: $(echo -n &quot;SCRAM-SHA-512&quot; | base64)
EOF

# Create TriggerAuthentication for KEDA
kubectl apply -f - &lt;&lt;EOF
apiVersion: keda.sh/v1alpha1
kind: TriggerAuthentication
metadata:
  name: msk-scram-auth
  namespace: knative-eventing
spec:
  secretTargetRef:
  - parameter: username
    name: kafka-secret
    key: user
  - parameter: password
    name: kafka-secret
    key: password
EOF
</code></pre>
<h2>Step 3: Test Dispatcher Scaling</h2>
<h3>3.1 Create a ScaledObject for kafka-broker-dispatcher</h3>
<pre><code class="language-yaml"># dispatcher-scaledobject.yaml
apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: kafka-broker-dispatcher
  namespace: knative-eventing
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: StatefulSet
    name: kafka-broker-dispatcher
  pollingInterval: 15                      # Check every 15 seconds
  cooldownPeriod: 180                      # Wait 3 minutes before scaling down
  minReplicaCount: 1
  maxReplicaCount: 20
  triggers:
  - type: kafka
    metadata:
      bootstrapServers: YOUR_MSK_BOOTSTRAP_SERVERS
      consumerGroup: knative-trigger-demo-trigger  # Consumer group for your trigger
      topic: knative-trigger-demo-trigger          # Topic for your trigger
      lagThreshold: &quot;50&quot;                           # Scale up when lag &gt; 50 messages
      activationLagThreshold: &quot;10&quot;                 # Keep at least 1 replica when lag &gt; 10
      tls: enable
      sasl: scram_sha512
      offsetResetPolicy: latest
    authenticationRef:
      name: msk-scram-auth
</code></pre>
<pre><code class="language-bash">kubectl apply -f dispatcher-scaledobject.yaml
</code></pre>
<h3>3.2 Test Annotation-Based Scaling for Triggers</h3>
<pre><code class="language-yaml"># keda-scaled-trigger.yaml
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: demo-trigger
  namespace: default
  annotations:
    autoscaling.knative.dev/class: &quot;keda.autoscaling.knative.dev&quot;
    autoscaling.knative.dev/minScale: &quot;0&quot;
    autoscaling.knative.dev/maxScale: &quot;5&quot;
    keda.autoscaling.knative.dev/lagThreshold: &quot;30&quot;
    keda.autoscaling.knative.dev/activationLagThreshold: &quot;5&quot;
    keda.autoscaling.knative.dev/pollingInterval: &quot;15&quot;
    keda.autoscaling.knative.dev/cooldownPeriod: &quot;60&quot;
spec:
  broker: demo-broker
  filter:
    attributes:
      type: dev.knative.samples.heartbeat
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: event-display
</code></pre>
<pre><code class="language-bash">kubectl apply -f keda-scaled-trigger.yaml
</code></pre>
<h2>Step 4: Load Testing Setup</h2>
<h3>4.1 Create Producer Job</h3>
<pre><code class="language-yaml"># kafka-producer-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: kafka-burst-producer
  namespace: default
spec:
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: producer
        image: docker.io/edenhill/kcat:1.7.1
        command: [&quot;/bin/sh&quot;, &quot;-c&quot;]
        args:
        - |
          for i in $(seq 1 10000); do
            printf &#39;{&quot;id&quot;:%d,&quot;timestamp&quot;:&quot;%s&quot;}\n&#39; &quot;$i&quot; &quot;$(date)&quot; \
              | kcat -P \
                  -b &quot;$BOOTSTRAP&quot; \
                  -t demo-topic \
                  -X security.protocol=SASL_SSL \
                  -X sasl.mechanism=SCRAM-SHA-512 \
                  -X sasl.username=&quot;$KAFKA_USER&quot; \
                  -X sasl.password=&quot;$KAFKA_PASS&quot;
          done
          echo &quot;âœ” Load test complete&quot;
        env:
        - name: BOOTSTRAP
          value: &quot;YOUR_MSK_BOOTSTRAP_SERVERS&quot;
        - name: KAFKA_USER
          valueFrom:
            secretKeyRef: {name: kafka-secret, key: user}
        - name: KAFKA_PASS
          valueFrom:
            secretKeyRef: {name: kafka-secret, key: password}
</code></pre>
<pre><code class="language-bash">kubectl apply -f kafka-producer-job.yaml
</code></pre>
<h3>4.2 Create Consumer Application</h3>
<pre><code class="language-yaml"># kafka-consumer-app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka-demo-consumer
  namespace: default
spec:
  replicas: 0  # Start with 0 replicas
  selector:
    matchLabels: {app: kafka-demo-consumer}
  template:
    metadata:
      labels: {app: kafka-demo-consumer}
    spec:
      containers:
      - name: consumer
        image: docker.io/edenhill/kcat:1.7.1
        command: [&quot;/bin/sh&quot;, &quot;-c&quot;]
        args:
        - |
          kcat -C \
               -b &quot;$BOOTSTRAP&quot; \
               -t demo-topic \
               -G demo-group \
               -X security.protocol=SASL_SSL \
               -X sasl.mechanism=SCRAM-SHA-512 \
               -X sasl.username=&quot;$KAFKA_USER&quot; \
               -X sasl.password=&quot;$KAFKA_PASS&quot; \
               -q
        env:
        - name: BOOTSTRAP
          value: &quot;YOUR_MSK_BOOTSTRAP_SERVERS&quot;
        - name: KAFKA_USER
          valueFrom:
            secretKeyRef: {name: kafka-secret, key: user}
        - name: KAFKA_PASS
          valueFrom:
            secretKeyRef: {name: kafka-secret, key: password}
</code></pre>
<pre><code class="language-bash">kubectl apply -f kafka-consumer-app.yaml
</code></pre>
<h2>Step 5: Verification and Monitoring</h2>
<h3>5.1 Monitor Dispatcher Scaling</h3>
<pre><code class="language-bash"># Watch dispatcher pods scaling
kubectl get pods -n knative-eventing -l app=kafka-broker-dispatcher -w

# Check dispatcher StatefulSet status
kubectl get statefulset kafka-broker-dispatcher -n knative-eventing

# Monitor KEDA ScaledObject status
kubectl get scaledobject kafka-broker-dispatcher -n knative-eventing -o yaml
</code></pre>
<h3>5.2 Monitor Consumer Group Lag</h3>
<pre><code class="language-bash"># Check consumer group lag (using kafka-consumer-groups)
kubectl run kafka-client --image=confluentinc/cp-kafka:latest --rm -it -- \
  kafka-consumer-groups \
  --bootstrap-server YOUR_MSK_BOOTSTRAP_SERVERS \
  --group demo-group \
  --describe \
  --command-config /etc/kafka/consumer.properties

# Monitor KEDA metrics for lag
kubectl get --raw &quot;/apis/external.metrics.k8s.io/v1beta1/namespaces/default/kafka-demo-group-demo-topic&quot;
</code></pre>
<h3>5.3 Verify Receiver Scaling</h3>
<pre><code class="language-bash"># Monitor receiver deployment
kubectl get deployment kafka-broker-receiver -n knative-eventing -w

# Check receiver service endpoints
kubectl get endpoints kafka-broker-ingress -n knative-eventing

# Monitor receiver metrics
kubectl port-forward -n knative-eventing deployment/kafka-broker-receiver 9090:9090
# Access http://localhost:9090/metrics
</code></pre>
<h3>5.4 Test Scaling Behavior</h3>
<pre><code class="language-bash"># 1. Generate load and watch scaling
kubectl apply -f kafka-producer-job.yaml

# 2. Monitor scaling in real-time
watch kubectl get pods -l app=kafka-demo-consumer

# 3. Check KEDA scaler metrics
kubectl get hpa -A | grep keda

# 4. Monitor dispatcher scaling
kubectl get statefulset kafka-broker-dispatcher -n knative-eventing -w

# 5. Check trigger scaling (if using annotation-based)
kubectl get scaledobject -A
</code></pre>
<h3>5.5 Debugging Commands</h3>
<pre><code class="language-bash"># Check KEDA operator logs
kubectl logs -n keda deployment/keda-operator -f

# Check KEDA metrics server
kubectl logs -n keda deployment/keda-metrics-apiserver -f

# Describe ScaledObject for detailed status
kubectl describe scaledobject kafka-broker-dispatcher -n knative-eventing

# Check trigger authentication
kubectl describe triggerauthentication msk-scram-auth -n knative-eventing

# Monitor Kafka broker controller logs
kubectl logs -n knative-eventing deployment/kafka-controller -f
</code></pre>
<h2>Step 6: Performance Validation</h2>
<h3>6.1 Key Metrics to Monitor</h3>
<ol>
<li><p><strong>Dispatcher Scaling</strong>:</p>
<ul>
<li>CPU/Memory utilization: <code>kubectl top pods -n knative-eventing -l app=kafka-broker-dispatcher</code></li>
<li>Replica count: <code>kubectl get statefulset kafka-broker-dispatcher -n knative-eventing</code></li>
<li>Message processing rate: Check metrics endpoint</li>
</ul>
</li>
<li><p><strong>Consumer Group Lag</strong>:</p>
<ul>
<li>Current lag: Via kafka-consumer-groups command</li>
<li>KEDA lag metrics: Via external metrics API</li>
<li>Scaling triggers: Check ScaledObject status</li>
</ul>
</li>
<li><p><strong>Receiver Performance</strong>:</p>
<ul>
<li>Request throughput: Monitor ingress metrics</li>
<li>Response times: Check receiver metrics endpoint</li>
<li>Error rates: Monitor logs and metrics</li>
</ul>
</li>
</ol>
<h3>6.2 Expected Scaling Behavior</h3>
<ul>
<li><strong>Scale Up</strong>: When consumer group lag exceeds <code>lagThreshold</code> (50 messages)</li>
<li><strong>Scale Down</strong>: After <code>cooldownPeriod</code> (180 seconds) when lag is below threshold</li>
<li><strong>Minimum Replicas</strong>: Always maintains <code>minReplicaCount</code> (1)</li>
<li><strong>Maximum Replicas</strong>: Never exceeds <code>maxReplicaCount</code> (20)</li>
</ul>
<h3>6.3 Troubleshooting Common Issues</h3>
<ol>
<li><p><strong>Scaling Not Triggered</strong>:</p>
<ul>
<li>Check TriggerAuthentication credentials</li>
<li>Verify MSK connectivity from pods</li>
<li>Check consumer group exists and has lag</li>
</ul>
</li>
<li><p><strong>Authentication Errors</strong>:</p>
<ul>
<li>Verify SCRAM credentials are correct</li>
<li>Check MSK cluster security groups</li>
<li>Ensure TLS is properly configured</li>
</ul>
</li>
<li><p><strong>Performance Issues</strong>:</p>
<ul>
<li>Adjust resource limits for dispatcher</li>
<li>Tune polling intervals and cooldown periods</li>
<li>Monitor network latency to MSK</li>
</ul>
</li>
</ol>
<h2>Architecture Summary</h2>
<p>KEDA scales Knative Kafka components through two primary mechanisms:</p>
<h3>1. <strong>Direct ScaledObject for kafka-broker-dispatcher</strong></h3>
<ul>
<li><strong>Component</strong>: <code>kafka-broker-dispatcher</code> (StatefulSet)</li>
<li><strong>Scaling Metric</strong>: Consumer group lag from MSK</li>
<li><strong>Configuration</strong>: Explicit ScaledObject with Kafka trigger</li>
<li><strong>Use Case</strong>: Scales the dispatcher based on pending messages to process</li>
</ul>
<h3>2. <strong>Annotation-Based Scaling for Triggers</strong></h3>
<ul>
<li><strong>Component</strong>: Individual consumer groups created per Trigger</li>
<li><strong>Scaling Metric</strong>: Consumer group lag per trigger</li>
<li><strong>Configuration</strong>: Annotations on Trigger resources</li>
<li><strong>Use Case</strong>: Scales individual trigger processing capacity</li>
</ul>
<h3>3. <strong>kafka-broker-receiver Scaling</strong></h3>
<ul>
<li><strong>Component</strong>: <code>kafka-broker-receiver</code> (Deployment)</li>
<li><strong>Scaling Metric</strong>: HTTP request volume or connection count</li>
<li><strong>Configuration</strong>: Standard Kubernetes HPA or KEDA ScaledObject</li>
<li><strong>Use Case</strong>: Scales ingress capacity for incoming events</li>
</ul>
<p>The key insight is that KEDA provides <strong>lag-based autoscaling</strong> for Kafka workloads, where:</p>
<ul>
<li>Each Trigger gets its own consumer group</li>
<li>Each consumer group can scale independently based on message lag</li>
<li>The dispatcher component scales to handle multiple consumer groups efficiently</li>
<li>The receiver component scales to handle incoming event ingress</li>
</ul>
<p>This architecture allows for fine-grained scaling based on actual Kafka message processing demand rather than just CPU/memory metrics.</p>
<h2>Key Annotations for KEDA Scaling</h2>
<pre><code class="language-yaml"># Essential annotations for Trigger-based scaling
annotations:
  autoscaling.knative.dev/class: &quot;keda.autoscaling.knative.dev&quot;
  autoscaling.knative.dev/minScale: &quot;0&quot;
  autoscaling.knative.dev/maxScale: &quot;5&quot;
  keda.autoscaling.knative.dev/lagThreshold: &quot;30&quot;
  keda.autoscaling.knative.dev/activationLagThreshold: &quot;5&quot;
  keda.autoscaling.knative.dev/pollingInterval: &quot;15&quot;
  keda.autoscaling.knative.dev/cooldownPeriod: &quot;60&quot;
</code></pre>
<h2>Next Steps</h2>
<ol>
<li><strong>Configure Prometheus monitoring</strong> for KEDA metrics</li>
<li><strong>Set up Grafana dashboards</strong> for visualization</li>
<li><strong>Implement alerting</strong> for scaling events</li>
<li><strong>Tune performance</strong> based on your workload characteristics</li>
<li><strong>Test failure scenarios</strong> and recovery mechanisms</li>
</ol>

</body>
</html>